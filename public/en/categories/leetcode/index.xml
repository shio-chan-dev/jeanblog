<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on Jeanphilo Blog</title>
    <link>http://localhost:1313/en/categories/leetcode/</link>
    <description>Recent content in LeetCode on Jeanphilo Blog</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Dec 2025 11:40:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/en/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data Structures Basics: Number of Good Pairs (Hash Counting ACERS)</title>
      <link>http://localhost:1313/en/alg/leetcode/good-pairs-count-acers/</link>
      <pubDate>Tue, 30 Dec 2025 11:40:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/good-pairs-count-acers/</guid>
      <description>Solve Good Pairs with one-pass hash counting, plus engineering scenarios, complexity, and multi-language solutions.</description>
    </item>
    <item>
      <title>Sorting Series (Final): Practical Selection - Choose by Scale, Stability, Memory, Distribution</title>
      <link>http://localhost:1313/en/alg/leetcode/9.sorting-series-selection-guide/</link>
      <pubDate>Tue, 09 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/9.sorting-series-selection-guide/</guid>
      <description>Practical selection guide: decision tables by scale/distribution/stability/memory, engineering scenarios, test checklist, and common pitfalls to apply the series.</description>
    </item>
    <item>
      <title>Sorting Series (8): TimSort and Introsort - Engineering Patterns Behind Built-in Sorts</title>
      <link>http://localhost:1313/en/alg/leetcode/8.sorting-series-timsort-introsort/</link>
      <pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/8.sorting-series-timsort-introsort/</guid>
      <description>Explain Python/Java TimSort and C++ std::sort Introsort: triggers, stability, complexity, trade-offs, with skeletons and selection guidance.</description>
    </item>
    <item>
      <title>Sorting Series (7): Non-Comparison Sorting - Counting, Bucket, Radix and the Range/Digit Tradeoff</title>
      <link>http://localhost:1313/en/alg/leetcode/7.sorting-series-non-comparison/</link>
      <pubDate>Sun, 07 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/7.sorting-series-non-comparison/</guid>
      <description>Explain prerequisites, complexity, implementation details, and pitfalls of non-comparison sorts with multilingual examples for counting, bucket, and radix.</description>
    </item>
    <item>
      <title>Sorting Series (6): Heap Sort - In-place O(n log n) with Worst-Case Guarantees</title>
      <link>http://localhost:1313/en/alg/leetcode/6.sorting-series-heap-sort/</link>
      <pubDate>Sat, 06 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/6.sorting-series-heap-sort/</guid>
      <description>Explain heap sort principles, complexity, and engineering scenarios; compare with quick/merge; include multilingual implementations and top-k examples.</description>
    </item>
    <item>
      <title>Sorting Series (5): Quick Sort - Pivot Strategy, Tail Recursion, Engineering Practice</title>
      <link>http://localhost:1313/en/alg/leetcode/5.sorting-series-quick-sort/</link>
      <pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/5.sorting-series-quick-sort/</guid>
      <description>Comprehensive quicksort guide: pivot selection, three-way partitioning, tail recursion optimization, hybrid sorting practices, with multilingual implementations and engineering guidance.</description>
    </item>
    <item>
      <title>Find First and Last Position of Element in Sorted Array</title>
      <link>http://localhost:1313/en/alg/leetcode/binary-search-search-range-start-end/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/binary-search-search-range-start-end/</guid>
      <description>&lt;h1 id=&#34;find-first-and-last-position-of-element-in-sorted-array&#34;&gt;Find First and Last Position of Element in Sorted Array&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Given a sorted array, return the first and last index of a target value, or &lt;code&gt;[-1, -1]&lt;/code&gt; if not found. Use lower_bound and upper_bound.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;l = lower_bound(target)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r = upper_bound(target) - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;l&lt;/code&gt; is out of range or &lt;code&gt;nums[l] != target&lt;/code&gt;, return &lt;code&gt;[-1, -1]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(log n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; bisect &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect_left, bisect_right
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search_range&lt;/span&gt;(nums, target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_left(nums, target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_right(nums, target) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; l &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; len(nums) &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; nums[l] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; target:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [l, r]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Find Target Indices After Sorting</title>
      <link>http://localhost:1313/en/alg/leetcode/binary-search-find-target-index/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/binary-search-find-target-index/</guid>
      <description>&lt;h1 id=&#34;find-target-indices-after-sorting&#34;&gt;Find Target Indices After Sorting&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Sort the array and return all indices where the target appears. Use binary search to find the range efficiently.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sort the array.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;bisect_left&lt;/code&gt; and &lt;code&gt;bisect_right&lt;/code&gt; to get &lt;code&gt;[l, r)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Return &lt;code&gt;list(range(l, r))&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n log n)&lt;/li&gt;
&lt;li&gt;Space: O(n) if sorting a copy&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; bisect &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect_left, bisect_right
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target_indices&lt;/span&gt;(nums, target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    nums &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sorted(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    l &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_left(nums, target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_right(nums, target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; list(range(l, r))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>High-Value Sliding Window Applications: From Max Vowels to Real Monitoring</title>
      <link>http://localhost:1313/en/alg/leetcode/sliding-window-max-vowel-substring-to-monitoring/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/sliding-window-max-vowel-substring-to-monitoring/</guid>
      <description>&lt;h1 id=&#34;sliding-window-in-engineering-max-vowels-to-monitoring&#34;&gt;Sliding Window in Engineering: Max Vowels to Monitoring&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Sliding window is a simple but powerful pattern. The LeetCode problem &amp;ldquo;Maximum Number of Vowels in a Substring of Given Length&amp;rdquo; is a clean entry point and maps to real monitoring windows.&lt;/p&gt;
&lt;h2 id=&#34;approach-max-vowels&#34;&gt;Approach (max vowels)&lt;/h2&gt;
&lt;p&gt;Keep a window of length &lt;code&gt;k&lt;/code&gt;, maintain a running count of vowels, and update the maximum.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max_vowels&lt;/span&gt;(s, k):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vowels &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aeiou&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; s[:k] &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; vowels)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(k, len(s)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;k] &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; vowels:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s[i] &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; vowels:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cur &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(ans, cur)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Maximum Count of Positive and Negative Numbers</title>
      <link>http://localhost:1313/en/alg/leetcode/binary-search-maximum-count-positive-negative/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/binary-search-maximum-count-positive-negative/</guid>
      <description>&lt;h1 id=&#34;maximum-count-of-positive-and-negative-numbers&#34;&gt;Maximum Count of Positive and Negative Numbers&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Given a sorted array, return the maximum of the number of positive and negative values. Binary search gives the split points in O(log n).&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;bisect_left(nums, 0)&lt;/code&gt; to get count of negatives.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;bisect_right(nums, 0)&lt;/code&gt; to get first positive index.&lt;/li&gt;
&lt;li&gt;Positive count = &lt;code&gt;n - right_zero&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(log n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; bisect &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect_left, bisect_right
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maximum_count&lt;/span&gt;(nums):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(nums)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    neg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_left(nums, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; bisect_right(nums, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(neg, pos)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Maximum Sum of Almost Unique Subarray</title>
      <link>http://localhost:1313/en/alg/leetcode/almost-unique-subarray-max-sum/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/almost-unique-subarray-max-sum/</guid>
      <description>&lt;h1 id=&#34;maximum-sum-of-almost-unique-subarray&#34;&gt;Maximum Sum of Almost Unique Subarray&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Given an array, window size &lt;code&gt;k&lt;/code&gt;, and threshold &lt;code&gt;m&lt;/code&gt;, find the maximum sum of any length-&lt;code&gt;k&lt;/code&gt; subarray that contains at least &lt;code&gt;m&lt;/code&gt; distinct elements.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;p&gt;Use a sliding window with a frequency map, track window sum and number of distinct values.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n)&lt;/li&gt;
&lt;li&gt;Space: O(n) for frequency map&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;max_sum_almost_unique&lt;/span&gt;(nums, m, k):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; collections &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; defaultdict
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; defaultdict(int)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    distinct &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    window_sum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(nums):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        window_sum &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; x
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; count[x] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            distinct &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        count[x] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; k:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; k]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            window_sum &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; y
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            count[y] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; count[y] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                distinct &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; distinct &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; m:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(ans, window_sum)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Minimum Recolors to Get K Consecutive Black Blocks</title>
      <link>http://localhost:1313/en/alg/leetcode/minimum-recolors-k-consecutive-black-blocks/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/minimum-recolors-k-consecutive-black-blocks/</guid>
      <description>&lt;h1 id=&#34;minimum-recolors-to-get-k-consecutive-black-blocks&#34;&gt;Minimum Recolors to Get K Consecutive Black Blocks&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Given a string of &amp;lsquo;B&amp;rsquo; and &amp;lsquo;W&amp;rsquo;, find the minimum recolors to make a substring of length &lt;code&gt;k&lt;/code&gt; all black.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;p&gt;Use a sliding window of length &lt;code&gt;k&lt;/code&gt; and count the number of whites in the window. The minimum whites across all windows is the answer.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minimum_recolors&lt;/span&gt;(blocks, k):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    whites &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; blocks[:k] &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;W&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; whites
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(k, len(blocks)):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; blocks[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;k] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;W&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            whites &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; blocks[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;W&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            whites &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(ans, whites)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ans
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Search Insert Position: Binary Search for the Insert Index</title>
      <link>http://localhost:1313/en/alg/leetcode/binary-search-search-insert-position/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/binary-search-search-insert-position/</guid>
      <description>&lt;h1 id=&#34;search-insert-position&#34;&gt;Search Insert Position&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Find the index where a target should be inserted into a sorted array. If it exists, return its index; otherwise return the insertion position. This is a classic lower_bound binary search.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;p&gt;Use binary search to find the first index &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;nums[i] &amp;gt;= target&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(log n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; bisect &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect_left
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;search_insert&lt;/span&gt;(nums, target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bisect_left(nums, target)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Smallest Letter Greater Than Target</title>
      <link>http://localhost:1313/en/alg/leetcode/binary-search-smallest-letter-greater-than-target/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/binary-search-smallest-letter-greater-than-target/</guid>
      <description>&lt;h1 id=&#34;smallest-letter-greater-than-target&#34;&gt;Smallest Letter Greater Than Target&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Given a sorted list of letters with wrap-around, return the smallest letter strictly greater than the target.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;p&gt;Use &lt;code&gt;bisect_right&lt;/code&gt; to find the first letter greater than target. If index reaches the end, wrap to index 0.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(log n)&lt;/li&gt;
&lt;li&gt;Space: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; bisect &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect_right
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next_greatest_letter&lt;/span&gt;(letters, target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect_right(letters, target)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; letters[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(letters) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; letters[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Spells and Potions: Count Successful Pairs</title>
      <link>http://localhost:1313/en/alg/leetcode/spells-and-potions-successful-pairs/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/spells-and-potions-successful-pairs/</guid>
      <description>&lt;h1 id=&#34;spells-and-potions&#34;&gt;Spells and Potions&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;For each spell, count how many potions make &lt;code&gt;spell * potion &amp;gt;= success&lt;/code&gt;. Sort potions and binary search the threshold.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sort potions.&lt;/li&gt;
&lt;li&gt;For each spell, compute &lt;code&gt;need = ceil(success / spell)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use binary search to find the first potion &amp;gt;= need.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n log n)&lt;/li&gt;
&lt;li&gt;Space: O(1) extra (or O(n) if sorting a copy)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; bisect
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; math
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;successful_pairs&lt;/span&gt;(spells, potions, success):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    potions &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sorted(potions)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(potions)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; spells:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        need &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (success &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; s
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bisect&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bisect_left(potions, need)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; idx)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Two Sum with Hash Map (ACERS Summary)</title>
      <link>http://localhost:1313/en/alg/leetcode/two-sum-hash-map-acers/</link>
      <pubDate>Thu, 04 Dec 2025 11:10:00 +0800</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/two-sum-hash-map-acers/</guid>
      <description>&lt;h1 id=&#34;two-sum&#34;&gt;Two Sum&lt;/h1&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Find two indices such that &lt;code&gt;nums[i] + nums[j] = target&lt;/code&gt;. Use a hash map for O(n) time.&lt;/p&gt;
&lt;h2 id=&#34;approach&#34;&gt;Approach&lt;/h2&gt;
&lt;p&gt;Iterate and store &lt;code&gt;value -&amp;gt; index&lt;/code&gt;. For each number &lt;code&gt;x&lt;/code&gt;, check if &lt;code&gt;target - x&lt;/code&gt; exists.&lt;/p&gt;
&lt;h2 id=&#34;complexity&#34;&gt;Complexity&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Time: O(n)&lt;/li&gt;
&lt;li&gt;Space: O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python-reference-implementation&#34;&gt;Python reference implementation&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;two_sum&lt;/span&gt;(nums, target):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    seen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(nums):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; x
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; seen:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; [seen[y], i]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        seen[x] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Sorting Series (4): Merge Sort - Stable Divide and Conquer and External Sorting</title>
      <link>http://localhost:1313/en/alg/leetcode/4.sorting-series-merge-sort/</link>
      <pubDate>Thu, 04 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/4.sorting-series-merge-sort/</guid>
      <description>Systematic explanation of merge sort principles, stability, space trade-offs, and engineering scenarios with Python/C/C++/Go/Rust/JS implementations and external sorting guidance.</description>
    </item>
    <item>
      <title>Sorting Series (3): Shell Sort - From Insertion to Gap-Based Efficiency</title>
      <link>http://localhost:1313/en/alg/leetcode/3.sorting-series-shell-sort/</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/3.sorting-series-shell-sort/</guid>
      <description>Explain Shell sort principles, gap strategies, and engineering usage with scenarios and Python/C/C++/Go/Rust/JS implementations.</description>
    </item>
    <item>
      <title>Sorting Series (2): Bubble, Selection, Insertion - Three O(n^2) Baselines</title>
      <link>http://localhost:1313/en/alg/leetcode/2.sorting-series-on2-baseline/</link>
      <pubDate>Tue, 02 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/2.sorting-series-on2-baseline/</guid>
      <description>Systematic ACERS explanation of bubble/selection/insertion sorts: principles, stability, scenarios, and multilingual implementations with selection guidance.</description>
    </item>
    <item>
      <title>Sorting Series (1): How to Choose an Algorithm - Time, Space, Stability, Scenarios</title>
      <link>http://localhost:1313/en/alg/leetcode/1.sorting-series-preface/</link>
      <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/en/alg/leetcode/1.sorting-series-preface/</guid>
      <description>Use the ACERS template to map common sorting algorithms by scenario, complexity, stability, and engineering usage, with runnable examples and a selection checklist.</description>
    </item>
  </channel>
</rss>
