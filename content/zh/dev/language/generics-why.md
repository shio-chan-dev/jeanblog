---
title: "泛型有什么用：复用、安全与表达力"
date: 2026-01-24T12:53:37+08:00
draft: false
description: "解释泛型的价值、适用场景与常见误区。"
tags: ["语言设计", "泛型", "类型系统", "复用"]
categories: ["语言设计"]
keywords: ["Generics", "泛型", "类型安全"]
---

## 副标题 / 摘要

泛型让代码在保持类型安全的同时实现复用。本文解释其价值与落地方式。

## 目标读者

- 想理解类型系统的开发者
- 需要写可复用组件的工程师
- 学习语言设计的同学

## 背景 / 动机

没有泛型时，复用通常依赖 `Object` 或手工复制，容易引入类型错误。  
泛型提供了编译期类型检查和更高的表达力。

## 核心概念

- **类型参数**：用类型占位符表达通用逻辑
- **类型安全**：编译期保证类型正确
- **复用**：同一逻辑适配多种类型

## 实践指南 / 步骤

1. **识别重复逻辑**  
2. **把类型差异抽成参数**  
3. **添加约束（如接口）**  
4. **保持 API 简洁**

## 可运行示例

```go
package main

import "fmt"

type Stack[T any] struct {
    data []T
}

func (s *Stack[T]) Push(v T) {
    s.data = append(s.data, v)
}

func (s *Stack[T]) Pop() T {
    v := s.data[len(s.data)-1]
    s.data = s.data[:len(s.data)-1]
    return v
}

func main() {
    s := Stack[int]{}
    s.Push(1)
    fmt.Println(s.Pop())
}
```

## 解释与原理

泛型让编译器在编译期发现类型错误，避免运行期崩溃。  
同时避免重复代码，提升维护性。

## 常见问题与注意事项

1. **泛型会影响性能吗？**  
   取决于语言实现，通常影响可控。

2. **什么时候不该用泛型？**  
   当逻辑过于简单或类型差异极少。

3. **泛型会让代码更复杂吗？**  
   可能，需权衡 API 可读性。

## 最佳实践与建议

- 保持泛型接口简洁
- 避免过度抽象
- 用约束限制可用类型

## 小结 / 结论

泛型的核心价值是“复用 + 类型安全”。  
用得好能大幅降低重复代码与类型错误。

## 参考与延伸阅读

- Java Generics
- Go Generics
- C++ Templates

## 元信息

- **阅读时长**：7~9 分钟  
- **标签**：泛型、类型系统  
- **SEO 关键词**：Generics, 泛型  
- **元描述**：解释泛型的价值与适用场景。

## 行动号召（CTA）

找一个重复的数据结构实现，用泛型改写它。
