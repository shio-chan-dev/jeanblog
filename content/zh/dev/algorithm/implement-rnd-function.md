---
title: "实现 rnd()：从基础随机数到可控随机"
date: 2026-01-24T13:20:24+08:00
draft: false
description: "解释随机数生成的基本思路，并用线性同余法实现一个简单 rnd()。"
tags: ["算法", "随机", "概率", "实现"]
categories: ["逻辑与算法"]
keywords: ["rnd", "随机数", "线性同余"]
---

## 副标题 / 摘要

随机数生成是很多算法的基础。本文用线性同余法实现一个可复现的 rnd()。

## 目标读者

- 学习随机算法的开发者
- 需要理解 PRNG 的工程师
- 算法与系统基础学习者

## 背景 / 动机

大多数语言的随机数来自伪随机算法。  
理解基础实现有助于评估随机性与可复现性。

## 核心概念

- **伪随机数（PRNG）**：由公式生成的序列
- **种子（Seed）**：决定序列起点
- **可复现性**：同样种子产生相同序列

## 实践指南 / 步骤

1. **选择线性同余参数**
2. **用种子初始化状态**
3. **每次调用更新状态并输出**
4. **将结果归一化到 [0,1)**

## 可运行示例

```python
class LCG:
    def __init__(self, seed=1):
        self.mod = 2 ** 31
        self.a = 1103515245
        self.c = 12345
        self.state = seed

    def rnd(self):
        self.state = (self.a * self.state + self.c) % self.mod
        return self.state / self.mod


if __name__ == "__main__":
    rng = LCG(seed=42)
    for _ in range(3):
        print(rng.rnd())
```

## 解释与原理

线性同余法是最简单的 PRNG：
`state = (a * state + c) mod m`。  
它速度快，但随机性质量有限。

## 常见问题与注意事项

1. **LCG 安全吗？**  
   不安全，不可用于加密。

2. **如何评估随机性？**  
   需要统计测试（如均匀分布）。

3. **为何需要种子？**  
   保证可复现，便于测试与调试。

## 最佳实践与建议

- 安全场景使用加密级随机数
- 需要可复现时固定种子
- 用库函数代替自研 PRNG

## 小结 / 结论

rnd() 可以用 LCG 轻松实现，但随机质量有限。  
工程中应根据场景选择更合适的随机数算法。

## 参考与延伸阅读

- Numerical Recipes: Random Numbers
- Python random 模块文档

## 元信息

- **阅读时长**：6~8 分钟  
- **标签**：随机数、PRNG  
- **SEO 关键词**：rnd, 伪随机数  
- **元描述**：讲解 rnd() 的基础实现与注意事项。

## 行动号召（CTA）

用不同种子生成序列，观察随机分布是否均匀。
