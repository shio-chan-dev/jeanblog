---
title: "判断一个数是否为2的幂:ACERS算法题解析与工程应用"
date: 2025-11-19T08:09:31+08:00
---
# **判断一个数是否为 2 的幂：ACERS 算法题解析与工程应用**

## A — Algorithm（题目与算法）

---

## **题目简介**

给定一个整数 `n`，判断它是否是 2 的幂。

**2 的幂** 是指：

```
1, 2, 4, 8, 16, 32, 64, ...
```

数学上等价于：

```
n = 2^k 且 k ≥ 0
```

编程中要求 **以最优方式判断**。

---

## **基础示例**

| 输入 | 输出    | 原因                  |
| -- | ----- | ------------------- |
| 1  | true  | 2⁰ = 1              |
| 8  | true  | 8 的二进制 1000         |
| 12 | false | 1100 中有两个 1，不是 2 的幂 |

**直观图示（8）**

```
8 = 1000₂
8 - 1 = 0111₂
8 & 7 = 0000   → 是 2 的幂
```

---

# C — Concepts（核心思想）

---

## **核心算法思想：位运算判断 2 的幂**

关键观察：

1. **2 的幂 → 二进制中只有一个 1**

   ```
   1   = 1
   2   = 10
   4   = 100
   8   = 1000
   16  = 10000
   ```

2. 若 n 是 2 的幂，则：

```
n      = 1000...000
n - 1  = 0111...111
n & (n - 1) = 0
```

因此可用一句话判断：

```cpp
(n > 0) && ((n & (n - 1)) == 0)
```

---

## **本题属于哪类题型？**

* ✔ **位运算（Bit Manipulation）**
* ✔ **位技巧（Bit Hacks）**
* ✔ **低层优化类算法（Low-level Optimization Pattern）**

本题是所有 bit 操作的入门级经典题。

---

# E — Engineering（工程应用）

下面给出 3 个**真实工程场景**，展示为什么“判断是否为 2 的幂”在工业界非常常见。

---

## **场景一：哈希表（Hash Table）的桶大小优化**

### **背景**

许多编程语言（Java HashMap、Redis、Go map）都使用 **2 的幂**作为哈希表数组长度。

原因：

* `index = hash & (capacity - 1)` 代替昂贵的取模 `%`
* 以位运算实现 O(1) 的映射

### **为什么用这个算法思想？**

需要在扩容时判断：

```
新容量是否是 2 的幂？
```

### **工程示例（Go map 伪代码）**

```go
func isPowerOfTwo(n int) bool {
    return n > 0 && (n & (n - 1)) == 0
}
```

在哈希表扩容时经常用到。

---

## **场景二：内存分配器（Allocator）中的块对齐**

### **背景**

很多内存池将块大小对齐至：

```
8, 16, 32, 64, 128 ...
```

判断一个 block size 是否为 2 的幂，是对齐的重要条件。

### **为什么？**

因为 2 的幂提供：

* CPU 级别加速（对齐访问更快）
* Cache 行更适配
* 简化 buddy memory allocator

### **工程示例（C 语言）**

```c
int is_pow2(size_t x) {
    return x > 0 && (x & (x - 1)) == 0;
}
```

---

## **场景三：多线程任务分配（Work-Sharding）**

### **背景**

分布式系统常把任务分成 2 的幂大小块，如：

* MapReduce 分片
* GPU warp 大小
* 并行线程数对齐

### **为什么要判断？**

为了判断：

* 分片数是否有效？
* 是否能使用 `index & (N - 1)` 快速映射任务？

### **工程示例（C++）**

```cpp
bool isPow2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

void scheduleShards(int shards) {
    if (!isPow2(shards)) throw invalid_argument("shards must be power of 2");
}
```

---

# R — Reflection（反思与深入）

---

## **算法正确性与复杂度**

### **正确性依据**

1. 2 的幂二进制只有一个 1
2. `n - 1` 会把这个 1 变成 0、把后面的全部变成 1
3. `n & (n - 1)` 只有在“只有单个 1”时才会是 0

这是 bit hack 中最稳定且经典的性质。

---

## **复杂度**

```
时间复杂度：O(1)
空间复杂度：O(1)
```

比任何数学法、循环法、除法法都快。

---

## **替代方案对比**

| 方法                 | 思路                           | 性能       | 问题        |
| ------------------ | ---------------------------- | -------- | --------- |
| 循环除 2              | 不断除以 2 看能否到 1                | O(log n) | 慢         |
| while(n%2==0) n/=2 | 判断是否一直可以整除 2                 | O(log n) | 整除、除法成本高  |
| 数 1 的数量            | `__builtin_popcount(n) == 1` | O(1)     | 依赖 CPU 指令 |
| **位运算（本解）**        | `n & (n-1)`                  | **O(1)** | 最快最优      |

因此：

> **位运算法是最简洁、最高效的标准答案**

---

# S — Summary（总结）

---

## **核心收获**

* 2 的幂的二进制形式非常特殊：只有一个 1
* 减 1 会把该 1 右边全部变成 1
* `n & (n - 1)` 判断是否只有一个 1
* 这是众多底层库、协议、分布式系统常用的技巧
* 工程中需要频繁判断容量、对齐、分片是否为 2 的幂

---

## **延伸阅读**

### **LeetCode 相关题目**

* 191. Number of 1 Bits
* 231. Power of Two（本题）
* 342. Power of Four
* 693. Binary Number with Alternating Bits

### **经典教材**

* 《算法（第四版）》Bitwise Operation 章节
* 《Computer Systems: A Programmer’s Perspective》 位运算章节
* MIT 6.046 / 6.172（关于 bit tricks 的课程）

### **工程文档**

* Go map 源码：runtime/map.go
* Redis dictionary 实现（dict.c）
* Linux slab/slub 内存分配器
