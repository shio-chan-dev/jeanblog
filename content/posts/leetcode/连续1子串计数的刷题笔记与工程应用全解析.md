---
title: "连续1子串计数的刷题笔记与工程应用全解析"
date: 2025-11-16T22:58:57+08:00
---
# **连续1子串计数的刷题笔记与工程应用全解析**

## **副标题 / 摘要**

本文从一道 LeetCode 算法题出发，深入解析“连续 1 子串计数算法”的原理，并展示其在真实工程中的多个典型应用场景（可运行示例附带）。适合希望从刷题过渡到工程能力提升的开发者。

---

## **目标读者**

* 正在刷 LeetCode / 准备面试的同学
* 想提升代码工程能力的开发者
* 数据分析、系统监控、机器学习方向工程师
* 需要分析连续事件序列的人（如日志分析、活跃度计算）

---

## **背景 / 动机：为什么这题值得写一篇博客？**

很多人刷到这题，会以为它只是简单的数学推导：

> 连续 1 的长度是 n
> 贡献子串数 = n(n+1)/2

但实际上：

* **连续事件统计是工程中极为常见的子任务**
* 日志监控、网络请求分析、图像处理、用户活跃度等都依赖它
* 算法题是简化后的版本，工程中往往是流式数据、实时分析

因此，把算法题的思想提炼出来，能直接提升工程能力。

---

## **核心概念**

### **1. 连续段（Run）**

在一个 0/1 序列中，连续的 1 或 0 构成一个 "run"。

例：

```
11100111
```

有两个长度为 3 和 3 的 1-run。

### **2. 子串贡献公式**

连续 1 长度 = n
所有只含 1 的子串数：

[
1 + 2 + ... + n = \frac{n(n+1)}{2}
]

这是全文最核心的数学结构。

### **3. 在线统计（Online algorithm）**

无需先找到所有连续段，而是边遍历边计算贡献。

---

## **实践指南 / 步骤**

### **算法步骤**

1. 遍历字符串
2. 使用 `last0` 记录最近出现的 `'0'`
3. 对每个 `'1'`：

   * 它作为结尾的合法子串数量 = `i - last0`
4. 用 `long long` 防止溢出
5. 最后再取模

---

## **可运行示例（题解代码）**

```cpp
class Solution {
public:
    int numSub(string s) {
        constexpr long long MOD = 1'000'000'007;
        long long ans = 0;
        int last0 = -1;

        for (int i = 0; i < (int)s.size(); i++) {
            if (s[i] == '0') {
                last0 = i;
            } else {
                ans += i - last0;
                ans %= MOD;
            }
        }
        return (int)ans;
    }
};
```

---

# **解释与原理：为什么这样做？**

### **1. 为什么使用 long long？**

因为最极端情况：

```
111111...(10 万次)
```

子串数接近：

[
5 \times 10^9 > 2^{31}-1
]

`int` 会溢出，提前模也救不回来。

### **2. 为什么是 i - last0？**

以 `i` 为结尾的只含 1 的区间为：

```
(last0+1, i)
(last0+2, i)
...
(i, i)
```

数量 = **i - last0**

---

# **实际工程应用场景 + 实现示例**

这部分是文章的重头戏，将算法与真实世界场景绑定。

---

## **场景一：网络请求稳定性分析（SLA 监控）**

### 背景

日志中记录每分钟请求是否成功：

```
1 = 成功
0 = 失败
```

你要统计：

> 整个期间内连续成功请求的总影响力（成功越连续越稳定）

### 实现代码（C++）

```cpp
long long countSuccessStreaks(const vector<int>& log) {
    long long total = 0;
    int lastFail = -1;

    for (int i = 0; i < log.size(); i++) {
        if (log[i] == 0) lastFail = i;
        else total += i - lastFail;
    }
    return total;
}
```

### 用途

* 服务稳定性评分
* 降级/报警依据
* 部署质量监控

---

## **场景二：用户活跃天数分析（Growth/运营必备）**

### 背景

每天是否打开 App：

```
1 = 打开
0 = 未打开
```

连续活跃天数越长 → 用户粘性越强。

### 代码示例（Python）

```python
def active_score(days):
    last_zero = -1
    score = 0
    for i, x in enumerate(days):
        if x == 0:
            last_zero = i
        else:
            score += i - last_zero
    return score
```

### 应用

* 活跃度评分
* 连续签到奖励
* 用户流失预测特征

---

## **场景三：图像处理（像素连续段长度）**

在 1D 像素行中：

```
1 = 高亮
0 = 背景
```

统计亮度连通段的贡献，用于：

* 边缘检测
* OCR 笔画长度统计
* 轮廓分析

### 示例代码（C++）

```cpp
int sumOfBrightSegments(const vector<int>& row) {
    int last0 = -1;
    long long sum = 0;
    for (int i = 0; i < row.size(); i++) {
        if (row[i] == 0) last0 = i;
        else sum += i - last0;
    }
    return sum;
}
```

---

## **场景四：DNA 序列分析（基因片段活跃区间）**

基因表达序列：

```
1 = 该基因在此位置被激活
0 = 未激活
```

统计活跃片段的数量和强度。

### 示例（Python）

```python
def gene_active_score(seq):
    last_zero = -1
    score = 0
    for i, x in enumerate(seq):
        if x == 0: last_zero = i
        else: score += i - last_zero
    return score
```

---

## **场景五：故障诊断（硬盘健康监控 / 心跳监控）**

系统每秒检测：

```
1 = 正常
0 = 异常
```

你要计算连续正常区间（代表系统健康度）

### 示例

```cpp
long long healthScore(const vector<int>& heartbeat) {
    int lastAbnormal = -1;
    long long score = 0;

    for (int i = 0; i < heartbeat.size(); i++) {
        if (heartbeat[i] == 0) lastAbnormal = i;
        else score += i - lastAbnormal;
    }
    return score;
}
```

---

# **常见问题与注意事项**

### ❗ 1. 为什么不是用 n(n+1)/2？

因为那需要先统计连续段，而本题可以 **在线计算**，速度更快。

### ❗ 2. 为什么要用 long long？

因为中间结果大于 2^31-1 会爆 int。

### ❗ 3. 能否实时流式处理？

是的，你的算法完全是 O(1) 空间、O(n) 单遍扫描，非常适合流式日志。

### ❗ 4. 是否能用于浮点数或非二值？

可以，只要先将数据转成 0/1（事件发生 / 未发生）。

---

# **最佳实践与建议**

* 使用 `long long` 避免溢出
* 对流式数据非常适用
* 可以作为机器学习特征（连续行为长度）
* 常用于探测系统稳定性与用户活跃度
* “连续区间贡献统计”是一类非常常见的工程需求

---

# **小结 / 结论**

本文通过一道经典算法题，扩展了以下能力：

1. **理解连续 1 子串计数的数学原理**
2. **掌握在线 O(n) 的高效算法**
3. **将刷题算法迁移到实际工程问题中**：

   * SLA 稳定性分析
   * 用户活跃度特征
   * 图像像素连通性
   * DNA 活跃片段
   * 心跳/故障监控

刷题不是目的，**把算法思想写进工程才是最终价值**。

---

# **参考与延伸阅读**

* LeetCode 1513 — Number of Substrings With Only 1s
* Run-Length Encoding（RLE）压缩算法
* 在线算法（Online Algorithm）
* 滑动窗口 / 前缀计数方法
* Real-time Event Stream Analytics

---

# **元信息**

* **阅读时长**：12 分钟
* **标签**：算法、工程实践、监控、数据分析
* **SEO 关键词**：连续 1、子串计数、在线算法、系统监控、SLA、DNA 序列、活跃度分析
* **元描述**：从 LeetCode 连续 1 子串问题出发，深入解析算法原理，并展示其在真实工程中的多个典型应用。

---

# **行动号召（CTA）**

如果你觉得这篇文章有用：

* ⭐ **收藏或点赞支持下我**
* 💬 **评论告诉我你最感兴趣的工程场景**
* 🔔 **关注我，后续我会写更多“算法 → 工程实践”的文章**

如果你愿意，我也可以把这篇内容：

* 制作成 **可发布的 PDF**
* 帮你用 **更适合知乎/CSDN 的排版**
* 或 **生成封面图 / 插图**

